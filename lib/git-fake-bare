# An example of how to add a new revision control system type to mr.
# git fake bare repositories have a detached workspace. One potential
# application is storing dotfiles in git, keeping them checked out in
# one $HOME, but checked into different git repositories. This file adds
# support for them, separate from the normal git support.

# To make mr use this file, add a line like this inside the [DEFAULT]
# section of your ~/.mrconfig
#include = cat /usr/share/mr/git-fake-bare

# And an example repo using it would look something like:
#[.dotfiles]
#lib = git_fake_bare_worktree $HOME
#checkout = git_fake_bare_checkout git://... .dotfiles

lib =
	# called to tell git where the worktree is
	git_fake_bare_worktree() {
		GIT_WORK_TREE="$1"; export GIT_WORK_TREE
	}
	# git doesn't have an easy way to check out such a repo, so
	# do it by hand
	git_fake_bare_checkout() {
		url="$1"
		repo="$2"
		GIT_WORK_TREE= git clone --no-checkout "$url" "$repo"
		cd "$repo"
		mkdir -p "$GIT_WORK_TREE"
		git read-tree HEAD
		git config core.worktree "$GIT_WORK_TREE"
		git checkout-index -a --prefix="$worktree" || true
		mv .git/* .
		rmdir .git
	}

git_fake_bare_test = 
	test -d "$MR_REPO"/refs/heads && test -d "$MR_REPO"/refs/tags &&
	test -d "$MR_REPO"/objects && test -f "$MR_REPO"/config &&
	test "$(GIT_CONFIG="$MR_REPO"/config git-config --get core.bare)" = false

git_fake_bare_update =
	# all this is because of a bug in git-fetch, which requires GIT_DIR set
	local git_dir_override; git_dir_override=.git
	case "$(get_git_repo_type "$MR_REPO")" in
		fake-bare) git_dir_override="$MR_REPO";;
	esac
	args="$@"
	[ -z "$args" ] && args="-t origin master"
	eval GIT_DIR="$git_dir_override" git pull "$args"

git_fake_bare_status = git status "$@" || true

git_fake_bare_commit = error "commit does not work for fake bare git repositories (yet)."

git_fake_bare_diff = error "diff does not work for fake bare git repositories (yet)."

git_fake_bare_log = git log "$@"

git_fake_bare_register = 
	url="$(LANG=C GIT_CONFIG=config git-config --get remote.origin.url)" || true
	if [ -z "$url" ]; then
		error "cannot determine git url"
	fi
	worktree="$(git-config --get core.worktree)" || true
	if [ -z "$worktree" ]; then
		error "git worktree is not set"
	fi
	worktree="${worktree%%/}/"
	if [ ! -d "$worktree" ]; then
		error "git worktree $worktree does not exist"
	fi
	mr -c "$MR_CONFIG" config "`pwd`" lib="git_fake_bare_worktree '$worktree'"
	echo "Registering git url: $url in $MR_CONFIG (with worktree $worktree)"
	mr -c "$MR_CONFIG" config "`pwd`" checkout="git_fake_bare_checkout '$url' '$MR_REPO'"
