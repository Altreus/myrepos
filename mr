#!/usr/bin/perl

=head1 NAME

mr - a Multiple Repository management tool

=head1 SYNOPSIS

B<mr> [options] checkout

B<mr> [options] update

B<mr> [options] status

B<mr> [options] commit [-m "message"]

B<mr> [options] diff

B<mr> [options] log

B<mr> [options] action [params ...]

=head1 DESCRIPTION

B<mr> is a Multiple Repository management tool. It allows you to register a
set of repositories in a .mrconfig file, and then checkout, update, or
perform other actions on the repositories as if they were one big
respository.

Any mix of revision control systems can be used with B<mr>, and you can
define arbitrary actions for commands like "update", "checkout", or "commit".

B<mr> cds into and operates on all registered repsitories at or below your
working directory. Or, if you are in a subdirectory of a repository that
contains no other registered repositories, it will stay in that directory,
and work on only that repository,

The predefined commands should be fairly familiar to users of any revision
control system:

=over 4

=item checkout (or co)

Checks out any repositories that are not already checked out.

=item update

Updates each repository from its configured remote repository.

If a repository isn't checked out yet, it will first check it out.

=item status

Displays a status report for each repository, showing what
uncommitted changes are present in the repository.

=item commit (or ci)

Commits changes to each repository. (By default, changes are pushed to the
remote repository too, when using distributed systems like git.)

The optional -m parameter allows specifying a commit message.

=item diff

Show a diff of uncommitted changes.

=item log

Show the commit log.

=item list (or ls)

List the repositories that mr will act on.

=item help

Displays this help.

=back

Actions can be abbreviated to any unambiguous subsctring, so
"mr st" is equivilant to "mr status", and "mr up" is equivilant to "mr
update"

Additional parameters can be passed to other commands than "commit", they
will be passed on unchanged to the underlying revision control system.
This is mostly useful if the repositories mr will act on all use the same
revision control system.

=head1 OPTIONS

=over 4

=item -d directory

Specifies the topmost directory that B<mr> should work in. The default is
the current working directory.

=item -c mrconfig

Use the specified mrconfig file, instead of looking for one in your home
directory.

=item -v

Be verbose.

=back

=head1 FILES

B<mr> is configured by .mrconfig files. It starts by reading the .mrconfig
file in your home directory, and this can in turn chain load .mrconfig files
from repositories.

Here is an example .mrconfig file:

  [src]
  checkout = svn co svn://svn.example.com/src/trunk src
  chain = true

  [src/linux-2.6]
  checkout = git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git

The .mrconfig file uses a variant of the INI file format. Lines starting with
"#" are comments. Lines ending with "\" are continued on to the next line.

The "default" section allows setting default values for the sections that
come after it.

The "alias" section allows adding aliases for actions. Each parameter
is an alias, and its value is the action to use.

All other sections specify where each repository is located, relative to the
directory that contains the .mrconfig file.

Within a section, each parameter defines a shell command to run to handle a
given action. mr contains default handlers for the "update", "status", and
"commit" actions, so normally you only need to specify what to do for
"checkout".

Note that these shell commands are run in a "set -e" shell
environment, where any additional parameters you pass are available in
"$@". The "checkout" command is run in the parent of the repository
directory, since the repository isn't checked out yet. All other commands
are run inside the repository, though not necessarily at the top of it.
The "MR_REPO" environment variable is set to the path to the top of the
repository.

A few parameters have special meanings:

=over 4

=item skip

If the "skip" parameter is set and its command returns nonzero, then B<mr>
will skip acting on that repository.

=item chain

If the "chain" parameter is set and its command returns nonzero, then B<mr>
will try to load a .mrconfig file from the root of the repository. (You
should avoid chaining from repositories with untrusted committers.)

=item lib

The "lib" parameter can specify some shell code that will be run before each
command, this can be a useful way to define shell functions for other commands
to use.

=back

=head1 AUTHOR

Copyright 2007 Joey Hess <joey@kitenet.net>

Licensed under the GNU GPL version 2 or higher.

http://kitenet.net/~joey/code/mr/

=cut

use warnings;
use strict;
use Getopt::Long;
use Cwd qw(getcwd abs_path);

my $directory=getcwd();
my $config="$ENV{HOME}/.mrconfig";
my $verbose=0;
my %config;
my %knownactions;
my %alias;

Getopt::Long::Configure("no_permute");
my $result=GetOptions(
	"d|directory=s" => sub { $directory=abs_path($_[1]) },
	"c|config=s" => \$config,
	"verbose" => \$verbose,
);
if (! $result || @ARGV < 1) {
	die("Usage: mr [-d directory] action [params ...]\n".
	    "(Use mr help for man page.)\n");

}

loadconfig(\*DATA);
loadconfig($config);
#use Data::Dumper;
#print Dumper(\%config);

eval {
	use FindBin qw($Bin $Script);
	$ENV{MR_PATH}=$Bin."/".$Script;
};

# alias expansion and command stemming
my $action=shift @ARGV;
if (exists $alias{$action}) {
	$action=$alias{$action};
}
if (! exists $knownactions{$action}) {
	my @matches = grep { /^\Q$action\E/ }
		keys %knownactions, keys %alias;
	if (@matches == 1) {
		$action=$matches[0];
	}
	elsif (@matches == 0) {
		die "mr: unknown action \"$action\" (known actions: ".
			join(", ", sort keys %knownactions).")\n";
	}
	else {
		die "mr: ambiguous action \"$action\" (matches: ".
			join(", ", @matches).")\n";
	}
}

if ($action eq 'help') {
	exec($config{''}{default}{help});
}

# work out what repos to act on
my @repos;
my $nochdir=0;
foreach my $topdir (sort keys %config) {
	foreach my $subdir (sort keys %{$config{$topdir}}) {
		next if $subdir eq 'default';
		my $dir=$topdir.$subdir;
		next if $dir ne $directory && $dir !~ /^\Q$directory\E\//;
		push @repos, [$dir, $topdir, $subdir];
	}
}
if (! @repos) {
	# fallback to find a leaf repo
	LEAF: foreach my $topdir (reverse sort keys %config) {
		foreach my $subdir (reverse sort keys %{$config{$topdir}}) {
			next if $subdir eq 'default';
			my $dir=$topdir.$subdir;
			my $d=$directory;
			$dir.="/" unless $dir=~/\/$/;
			$d.="/" unless $d=~/\/$/;
			if ($d=~/^\Q$dir\E/) {
				push @repos, [$dir, $topdir, $subdir];
				last LEAF;
			}
		}
	}
	$nochdir=1;
}

my (@failed, @successful, @skipped);
foreach my $repo (@repos) {
	action($action, @$repo);
}

sub action {
	my ($action, $dir, $topdir, $subdir) = @_;
	
	my $lib= exists $config{$topdir}{$subdir}{lib} ?
	                $config{$topdir}{$subdir}{lib} : "";

	if ($action eq 'checkout') {
		if (-d $dir) {
			print "mr $action: $dir already exists, skipping checkout\n" if $verbose;
			push @skipped, $dir;
			return;
		}
		$dir=~s/^(.*)\/[^\/]+\/?$/$1/;
	}
	elsif ($action eq 'update') {
		if (! -d $dir) {
			return action("checkout", $dir, $topdir, $subdir);
		}
	}
	
	$ENV{MR_REPO}=$dir;

	if (exists $config{$topdir}{$subdir}{skip}) {
		my $test="set -e;".$lib.$config{$topdir}{$subdir}{skip};
		print "mr $action: running skip test $test\n" if $verbose;
		my $ret=system($test);
		if ($ret >> 8 == 0) {
			print "mr $action: $dir skipped per config file\n" if $verbose;
			push @skipped, $dir;
			return;
		}
	}
	
	if (! $nochdir && ! chdir($dir)) {
		print STDERR "mr $action: failed to chdir to $dir: $!\n";
		push @failed, $dir;
	}
	elsif (! exists $config{$topdir}{$subdir}{$action}) {
		print STDERR "mr $action: no defined $action command for $topdir$subdir, skipping\n";
		push @skipped, $dir;
	}
	else {
		if (! $nochdir) {
			print "mr $action: $dir\n";
		}
		else {
			print "mr $action: $dir (in subdir $directory)\n";
		}
		my $command="set -e; ".$lib.
			"my_action(){ $config{$topdir}{$subdir}{$action} ; }; my_action ".
			join(" ", map { s/\//\/\//g; s/"/\"/g; '"'.$_.'"' } @ARGV);
		print STDERR "mr $action: running $command\n" if $verbose;
		my $ret=system($command);
		if ($ret != 0) {
			print STDERR "mr $action: failed ($ret)\n" if $verbose;
			push @failed, $topdir.$subdir;
			if ($ret >> 8 != 0) {
				print STDERR "mr $action: command failed\n";
			}
			elsif ($ret != 0) {
				print STDERR "mr $action: command died ($ret)\n";
			}
		}
		else {
			push @successful, $dir;
		}

		print "\n";
	}
}

sub showstat {
	my $count=shift;
	my $singular=shift;
	my $plural=shift;
	if ($count) {
		return "$count ".($count > 1 ? $plural : $singular);
	}
	return;
}
if (! @successful && ! @failed && ! @skipped) {
	die "mr $action: no repositories found to work on\n";
}
print "mr $action: finished (".join("; ",
	showstat($#successful+1, "successful", "successful"),
	showstat($#failed+1, "failed", "failed"),
	showstat($#skipped+1, "skipped", "skipped"),
).")\n";
if (@failed) {
	exit 1;
}
elsif (! @successful && @skipped) {
	exit 1;
}
exit 0;

my %loaded;
sub loadconfig {
	my $f=shift;

	my @toload;

	my $in;
	my $dir;
	if (ref $f eq 'GLOB') {
		$in=$f;	
		$dir="";
	}
	else {
		# $f might be a symlink
		my $absf=abs_path($f);
		if ($loaded{$absf}) {
			return;
		}
		$loaded{$absf}=1;

		print "mr: loading config $f\n" if $verbose;
		open($in, "<", $f) || die "mr: open $f: $!\n";
		($dir)=$f=~/^(.*\/)[^\/]+$/;
		if (! defined $dir) {
			$dir=".";
		}
		$dir=abs_path($dir)."/";

		# copy in defaults from first parent
		my $parent=$dir;
		while ($parent=~s/^(.*)\/[^\/]+\/?$/$1/) {
			if (exists $config{$parent} &&
			    exists $config{$parent}{default}) {
				$config{$dir}{default}={ %{$config{$parent}{default}} };
				last;
			}
		}
	}

	my $section;
	while (<$in>) {
		chomp;
		next if /^\s*\#/ || /^\s*$/;
		if (/^\s*\[([^\]]*)\]\s*$/) {
			$section=$1;
		}
		elsif (/^\s*(\w+)\s*=\s*(.*)/) {
			my $parameter=$1;
			my $value=$2;

			# continuation line
			while ($value=~/(.*)\\$/) {
				$value=$1.<$in>;
				chomp $value;
			}

			if (! defined $section) {
				die "$f line $.: parameter ($parameter) not in section\n";
			}
			if ($section ne 'alias' &&
			    ! exists $config{$dir}{$section} &&
			    exists $config{$dir}{default}) {
				# copy in defaults
				$config{$dir}{$section}={ %{$config{$dir}{default}} };
			}
			if ($section eq 'alias') {
				$alias{$parameter}=$value;
			}
			elsif ($parameter eq 'lib') {
				$config{$dir}{$section}{lib}.=$value." ; ";
			}
			else {
				$config{$dir}{$section}{$parameter}=$value;
				$knownactions{$parameter}=1;
				if ($parameter eq 'chain' &&
				    length $dir && $section ne "default" &&
				    -e $dir.$section."/.mrconfig" &&
			    	    system($value) >> 8 == 0) {
					push @toload, $dir.$section."/.mrconfig";
			        }
			}
		}
		else {
			die "$f line $.: parse error\n";
		}
	}
	close $in;

	foreach (@toload) {
		loadconfig($_);
	}
}

# Finally, some useful actions that mr knows about by default.
# These can be overridden in ~/.mrconfig.
__DATA__
[alias]
	co = checkout
	ci = commit
	ls = list

[default]
lib = \
	error() { \
		echo "mr: $@" >&2; \
		exit 1; \
	}

update = \
	if [ -d "$MR_REPO"/.svn ]; then \
		svn update "$@"; \
	elif [ -d "$MR_REPO"/.git ]; then \
		git pull origin master "$@"; \
	elif [ -d "$MR_REPO"/.bzr ]; then \
		bzr merge "$@"; \
	elif [ -d "$MR_REPO"/CVS ]; then \
		cvs update "$@"; \
	else \
		error "unknown repo type"; \
	fi
status = \
	if [ -d "$MR_REPO"/.svn ]; then \
		svn status "$@"; \
	elif [ -d "$MR_REPO"/.git ]; then \
		git status "$@" || true; \
	elif [ -d "$MR_REPO"/.bzr ]; then \
		bzr status "$@"; \
	elif [ -d "$MR_REPO"/CVS ]; then \
		cvs status "$@"; \
	else \
		error "unknown repo type"; \
	fi
commit = \
	if [ -d "$MR_REPO"/.svn ]; then \
		svn commit "$@"; \
	elif [ -d "$MR_REPO"/.git ]; then \
		git commit -a "$@" && git push --all; \
	elif [ -d "$MR_REPO"/.bzr ]; then \
		bzr commit "$@" && bzr push; \
	elif [ -d "$MR_REPO"/CVS ]; then \
		cvs commit "$@"; \
	else \
		error "unknown repo type"; \
	fi
diff = \
	if [ -d "$MR_REPO"/.svn ]; then \
		svn diff "$@"; \
	elif [ -d "$MR_REPO"/.git ]; then \
		git diff "$@"; \
	elif [ -d "$MR_REPO"/.bzr ]; then \
		bzr diff "$@"; \
	elif [ -d "$MR_REPO"/CVS ]; then \
		cvs diff "$@"; \
	else \
		error "unknown repo type"; \
	fi
log = \
	if [ -d "$MR_REPO"/.svn ]; then \
		svn log"$@"; \
	elif [ -d "$MR_REPO"/.git ]; then \
		git log "$@"; \
	elif [ -d "$MR_REPO"/.bzr ]; then \
		bzr log "$@"; \
	elif [ -d "$MR_REPO"/CVS ]; then \
		cvs log "$@"; \
	else \
		error "unknown repo type"; \
	fi
list = true

help = \
	if [ ! -e "$MR_PATH" ]; then \
		error "cannot find program path";\
	fi; \
	(pod2man -c mr "$MR_PATH" | man -l -) || \
		error "pod2man or man failed"

ed = echo "A horse is a horse, of course, of course.."
T = echo "I pity the fool."
